require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const bodyParser = require('body-parser');
const bcrypt = require('bcryptjs');
const cors = require('cors');
const User = require('./models/User');
const Expiration = require('./models/Expiration');
const { bot } = require('./utils/telegram');
const crypto = require('crypto');
const http = require('http');
const { sendWhatsAppMessage } = require('./utils/whatsapp');
const multer = require('multer');
const app = express();
const PORT = process.env.PORT || 8000;
const Video = require('./models/Video'); 
const server = http.createServer(app);
const ffmpeg = require('fluent-ffmpeg');
const path = require('path');
const os = require('os');
const { GridFSBucket } = require('mongodb');
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });
const phoneUtil = require('google-libphonenumber').PhoneNumberUtil.getInstance();

let gridFSBucketVideo;
let gridFSBucketImage;

// Middleware
app.use(cors());
app.use(bodyParser.json());

mongoose.connect(process.env.MONGODB_URI, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
  .then(() => {
    console.log('‚úÖ Connexion √† MongoDB r√©ussie');

    // Initialisation de GridFS apr√®s la connexion r√©ussie
    gridFSBucketVideo = new GridFSBucket(mongoose.connection.db, { bucketName: 'videos' });
    gridFSBucketImage = new GridFSBucket(mongoose.connection.db, { bucketName: 'images' });
  })
  .catch(err => {
    console.error('‚ùå Connexion √† MongoDB √©chou√©e:', err.message);
    console.error('D√©tails de l\'erreur:', err);
  });

// √âcoute des erreurs de connexion MongoDB
mongoose.connection.on('error', (err) => {
  console.error('‚ùå Erreur de connexion √† MongoDB:', err.message);
});

bot.launch();

const compressVideo = (inputBuffer) => {
  return new Promise((resolve, reject) => {
    // Cr√©er un fichier temporaire pour la vid√©o compress√©e
    const outputPath = path.join(os.tmpdir(), `compressed-${Date.now()}.mp4`);

    ffmpeg()
      .input(inputBuffer)
      .inputFormat('mp4')  // Format d'entr√©e
      .output(outputPath)
      .videoCodec('libx264')  // Codec H.264
      .size('1280x720')  // R√©solution (modifie selon tes besoins)
      .on('end', () => {
        resolve(outputPath);  // Retourne le chemin de la vid√©o compress√©e
      })
      .on('error', (err) => {
        reject(err);  // En cas d'erreur
      })
      .run();
  });
};


app.post('/register', async (req, res) => {
  const { name, phone, password } = req.body;

  try {
    // Formater le num√©ro de t√©l√©phone, sans contrainte sur le pr√©fixe
    let formattedPhone = phone.trim();

    // On ne fait plus de v√©rification stricte sur le pr√©fixe +226
    // Vous pouvez ajouter ici toute autre logique si n√©cessaire pour un autre formatage
    
    const hashedPassword = await bcrypt.hash(password, 10);
    const newUser = new User({
      name,
      phone: formattedPhone,  // Utilisation du num√©ro format√©
      password: hashedPassword,
      isVIPInformatique: false,
      isVIPMarketing: false,
      isVIPEnergie: false,
      isVIPReparation: false,
    });
    await newUser.save();

    // Message Telegram pour administrateur avec boutons pour chaque service
    const formations = [
      { type: 'Informatique', price: '30 000 FCFA' },
      { type: 'Marketing', price: '20 000 FCFA' },
      { type: 'Energie', price: '30 000 FCFA' },
      { type: 'R√©paration', price: '30 000 FCFA' },
    ];

    let telegramMessage = `üë§ *Nouvel utilisateur inscrit* :
üìõ *Nom* : ${name}
üìû *T√©l√©phone* : ${formattedPhone}

Veuillez valider ou annuler les formations demand√©es par cet utilisateur :\n`;

    formations.forEach((formation, index) => {
      telegramMessage += `\nüíº *${formation.type}* : ${formation.price}`;
    });

    // Cr√©e un tableau de lignes de boutons, o√π chaque ligne contient 2 boutons (valider et annuler)
    const inlineKeyboard = formations.map((formation) => {
      return [
        { 
          text: `‚úÖ ${formation.type}`, 
          callback_data: `validate_${formation.type}_${newUser._id}` // Ordre invers√© ici
        },
        { 
          text: `‚ùå ${formation.type}`, 
          callback_data: `reject_${formation.type}_${newUser._id}` 
        }
      ];
    });
    
    // Envoi du message avec les boutons format√©s correctement
    await bot.telegram.sendMessage(process.env.CHAT_ID, telegramMessage, {
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: inlineKeyboard, // Pas de .flat() ici
      },
    });

    // Message WhatsApp avec formations et coordonn√©es de paiement
    let formationsMessage = 'Voici nos diff√©rentes formations et leurs prix :\n\n';
    formations.forEach(formation => {
      formationsMessage += `üíº *${formation.type}* : ${formation.price}\n`;
    });

    const whatsappMessage = `
üéâ *Bienvenue chez Kaboretech*

Votre compte est en attente de validation.

${formationsMessage}

Nos coordonn√©es de paiement :
‚û° Orange Money : +226 74 39 19 80
‚û° Moov Money : +226 02 18 04 25

Cordialement,
*Kabore Tech*
`;

    await sendWhatsAppMessage(formattedPhone, whatsappMessage);

    res.status(201).json({ message: 'En attente de validation VIP' });
  } catch (error) {
    console.error('Erreur inscription:', error);
    res.status(500).json({ message: 'Erreur d\'inscription' });
  }
});

app.post('/api/login', async (req, res) => {
  const { phone, password } = req.body;
  let formattedPhone = phone.trim();

  try {
    const user = await User.findOne({ phone: formattedPhone });

    if (!user) return res.status(404).json({ message: 'Utilisateur non trouv√©' });

    const validPass = await bcrypt.compare(password, user.password);
    if (!validPass) return res.status(401).json({ message: 'Mot de passe incorrect' });

    res.status(200).json({
      message: 'Connexion r√©ussie',
      user: {
        name: user.name,
        phone: user.phone,
        price: user.price,
        vipStatus: {
          informatique: user.isVIPInformatique,
          marketing: user.isVIPMarketing,
          energie: user.isVIPEnergie,
          reparation: user.isVIPReparation,
        }
      }
    });
  } catch (error) {
    res.status(500).json({ message: 'Erreur de connexion' });
  }
});


// Modifier le handler des actions Telegram :
bot.action(/validate_(Informatique|Marketing|Energie|R√©paration)_([0-9a-fA-F]{24})/, async (ctx) => {
  const [_, formationType, userId] = ctx.match; // Ordre corrig√©
  const vipFieldMap = {
    'Informatique': 'isVIPInformatique',
    'Marketing': 'isVIPMarketing',
    'Energie': 'isVIPEnergie',
    'R√©paration': 'isVIPReparation'
  };

  const requiredPrice = formationType === 'Marketing' ? 20000 : 30000;
  const vipField = vipFieldMap[formationType];

  try {
    // Validation stricte de l'ID
    if (!mongoose.Types.ObjectId.isValid(userId)) {
      return ctx.answerCbQuery('‚ùå ID utilisateur invalide');
    }

    const user = await User.findById(userId);
    if (!user) return ctx.answerCbQuery('‚ùå Utilisateur introuvable');

    // V√©rification du prix
    if (user.price !== requiredPrice) {
      return ctx.answerCbQuery(`‚ùå Erreur: ${user.price}F au lieu de ${requiredPrice}F !`);
    }

    // Mise √† jour du statut VIP
    await User.updateOne({ _id: userId }, { $set: { [vipField]: true } });
    
    // Message de confirmation
    await ctx.answerCbQuery('‚úÖ VIP valid√© avec succ√®s !');
    await ctx.editMessageText(`‚úÖ Statut ${formationType} activ√© pour ${user.name}`);

    // Notification WhatsApp
    await sendWhatsAppMessage(
      user.phone,
      `üéâ F√©licitations ${user.name} !\nVotre acc√®s VIP ${formationType} est maintenant actif.`
    );

  } catch (error) {
    console.error('Erreur validation:', error);
    ctx.answerCbQuery('‚ùå Erreur lors de la validation');
  }
});
// Route pour oublier le mot de passe
app.post('/api/forgot-password', async (req, res) => {
  const { phone } = req.body;

  try {
    const user = await User.findOne({ phone });

    if (!user) {
      return res.status(404).json({ message: 'Num√©ro de t√©l√©phone non trouv√©.' });
    }

    const otp = crypto.randomInt(100000, 999999).toString();
    const otpExpiresAt = new Date(Date.now() + 5 * 60 * 1000); // Valide pour 5 minutes

    user.otp = otp;
    user.otpExpiresAt = otpExpiresAt;
    await user.save();

    const message = `Votre code de r√©initialisation de mot de passe est : ${otp}. Ce code est valide pendant 5 minutes.`;

    // Envoi du message WhatsApp avec le code OTP
    await sendWhatsAppMessage(phone, message);

    res.status(200).json({ message: 'Code OTP envoy√© avec succ√®s.' });
  } catch (error) {
    console.error('Erreur lors de l\'envoi de l\'OTP :', error);
    res.status(500).json({ message: 'Erreur interne du serveur.' });
  }
});

// V√©rification du code OTP
app.post('/api/verify-otp', async (req, res) => {
  const { phone, otp } = req.body;

  try {
    const user = await User.findOne({ phone, otp });
    const validUser = user && user.otpExpiresAt > new Date();

    if (!validUser) {
      return res.status(400).json({ message: 'Code OTP invalide ou expir√©.' });
    }

    res.status(200).json({ message: 'Code OTP valid√© avec succ√®s. Vous pouvez maintenant r√©initialiser votre mot de passe.' });
  } catch (error) {
    console.error('Erreur lors de la v√©rification de l\'OTP :', error);
    res.status(500).json({ message: 'Erreur interne du serveur.' });
  }
});

// R√©initialisation du mot de passe
app.post('/api/reset-password', async (req, res) => {
  const { phone, otp, newPassword } = req.body;

  try {
    const user = await User.findOne({ phone, otp });
    const validUser = user && user.otpExpiresAt > new Date();

    if (!validUser) {
      return res.status(400).json({ message: 'Code OTP invalide ou expir√©.' });
    }

    const hashedPassword = await bcrypt.hash(newPassword, 10);

    user.password = hashedPassword;
    user.otp = null;
    user.otpExpiresAt = null;
    await user.save();

    res.status(200).json({ message: 'Mot de passe r√©initialis√© avec succ√®s.' });

    // Envoi du message WhatsApp de confirmation apr√®s r√©initialisation
    const message = `‚úÖ Votre mot de passe a √©t√© r√©initialis√© avec succ√®s.`;
    await sendWhatsAppMessage(user.phone, message);
  } catch (error) {
    console.error('Erreur lors de la r√©initialisation du mot de passe :', error);
    res.status(500).json({ message: 'Erreur interne du serveur.' });
  }
});

app.get('/api/vip-status', async (req, res) => {
  let { phone } = req.query;
  
  // Conserver le '+' si pr√©sent dans le num√©ro
  phone = phone.trim();  // Supprimer les espaces superflus

  // Log du num√©ro de t√©l√©phone re√ßu
  console.log(`Num√©ro de t√©l√©phone re√ßu : ${phone}`);

  // Si le num√©ro ne commence pas par un "+", on ajoute le "+"
  if (!phone.startsWith('+')) {
    phone = '+' + phone;
  }

  // Log du num√©ro de t√©l√©phone avec le "+" ajout√© si n√©cessaire
  console.log(`Recherche de l'utilisateur avec le num√©ro : ${phone}`);

  try {
    // Recherche de l'utilisateur avec le num√©ro tel quel
    const user = await User.findOne({ phone: phone });

    if (!user) {
      console.log(`Utilisateur non trouv√© pour le num√©ro : ${phone}`);
      return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    }

    console.log(`Utilisateur trouv√© pour le num√©ro : ${phone}`);

    const activeVipDomains = [];
    if (user.isVIPInformatique) activeVipDomains.push('Informatique');
    if (user.isVIPMarketing) activeVipDomains.push('Marketing');
    if (user.isVIPEnergie) activeVipDomains.push('Energie');
    if (user.isVIPReparation) activeVipDomains.push('R√©paration');

    res.status(200).json({
      message: 'Statuts VIP r√©cup√©r√©s avec succ√®s',
      vipDomains: activeVipDomains
    });

  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des statuts VIP:', error);
    res.status(500).json({ message: 'Erreur interne lors de la r√©cup√©ration des statuts VIP' });
  }
});

// Nouvelle route pour v√©rifier le paiement et envoyer sur Telegram
app.post('/api/paiement', async (req, res) => {
  const { phone, numDepot, domaine, mode, price } = req.body;

  // Log du num√©ro de t√©l√©phone re√ßu
  console.log(`Num√©ro de t√©l√©phone re√ßu pour le paiement : ${phone.trim()}`);

  // V√©rification du domaine
  const validDomains = ['Informatique', 'Marketing', 'Energie', 'Reparation'];
  if (!validDomains.includes(domaine)) {
    return res.status(400).json({ message: 'Domaine invalide. Les domaines possibles sont : Informatique, Marketing, Energie, Reparation.' });
  }

  // V√©rification du mode de paiement
  const validModes = ['presentiel', 'ligne'];
  if (!validModes.includes(mode)) {
    return res.status(400).json({ message: 'Mode de paiement invalide. Les modes possibles sont : presentiel, ligne.' });
  }

  // V√©rification du prix (en fonction du domaine et du mode)
  const categoryPrices = {
    'Informatique': { presentiel: '45 000 ü™ô', ligne: '30 000 ü™ô' },
    'Marketing': { presentiel: '30 000 ü™ô', ligne: '20 000 ü™ô' },
    'Energie': { presentiel: '45 000 ü™ô', ligne: '30 000 ü™ô' },
    'Reparation': { presentiel: '45 000 ü™ô', ligne: '30 000 ü™ô' }
  };

  if (categoryPrices[domaine][mode] !== price) {
    return res.status(400).json({ message: 'Erreur de prix. Le prix ne correspond pas au mode de paiement s√©lectionn√©.' });
  }

  // Aucune modification du num√©ro n'est effectu√©e ici, on l'accepte tel quel
  let formattedPhone = phone.trim();
  console.log(`Recherche du paiement pour le num√©ro de t√©l√©phone : ${formattedPhone}`);

  // Ajouter le "+" si n√©cessaire avant de proc√©der √† la recherche
  if (!formattedPhone.startsWith('+')) {
    formattedPhone = '+' + formattedPhone;
  }

  try {
    // Recherche de l'utilisateur avec le num√©ro tel quel
    console.log(`Recherche de l'utilisateur avec le num√©ro : ${formattedPhone}`);
    const user = await User.findOne({ phone: formattedPhone });

    if (!user) {
      console.log(`Utilisateur non trouv√© pour le num√©ro : ${formattedPhone}`);
      return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    }

    console.log(`Utilisateur trouv√© pour le num√©ro : ${formattedPhone}`);

    // Envoi d'un message sur Telegram avec les informations
    const telegramMessage = `
    üì© *Nouveau Paiement Re√ßu*:

    üìù *Num√©ro de D√©p√¥t*: ${numDepot}
    üìû *Num√©ro d'Utilisateur*: ${formattedPhone}
    üíº *Domaine*: ${domaine}
    üåê *Mode de Paiement*: ${mode}
    üí∞ *Prix*: ${price}

    Veuillez proc√©der √† la validation du paiement et du statut VIP de l'utilisateur.
    `;

    // Envoi du message sur Telegram
    await bot.telegram.sendMessage(process.env.CHAT_ID, telegramMessage, {
      parse_mode: 'Markdown'
    });

    res.status(200).json({ message: 'Paiement v√©rifi√© et message envoy√© sur Telegram.' });
  } catch (error) {
    console.error('Erreur lors de l\'envoi du message Telegram:', error);
    res.status(500).json({ message: 'Erreur interne lors de la v√©rification du paiement.' });
  }
});

app.post('/api/add-video', upload.fields([{ name: 'videoFile', maxCount: 1 }, { name: 'imageFile', maxCount: 1 }]), async (req, res) => {
  const { title, categoryId, isPaid, description } = req.body;

  try {
    // V√©rifiez si les fichiers existent dans la m√©moire (buffer)
    if (!req.files.videoFile || !req.files.imageFile) {
      return res.status(400).json({ message: 'Les fichiers vid√©o et image sont requis.' });
    }

    // Stocker la vid√©o dans GridFS
    const videoFileId = await storeFileInGridFS(req.files.videoFile[0], gridFSBucketVideo);
    
    // Stocker l'image dans GridFS
    const imageFileId = await storeFileInGridFS(req.files.imageFile[0], gridFSBucketImage);

    // Cr√©er la vid√©o dans MongoDB
    const newVideo = new Video({
      title,
      categoryId,
      isPaid: isPaid === 'true',
      description,
      videoFileId,
      imageFileId
    });

    await newVideo.save();

    res.status(201).json({ 
      message: 'Vid√©o sauvegard√©e dans MongoDB !',
      video: newVideo 
    });

  } catch (error) {
    console.error('Erreur:', error);
    res.status(500).json({ message: error.message });
  }
});


const storeFileInGridFS = (file, bucket) => {
  return new Promise((resolve, reject) => {
    const uploadStream = bucket.openUploadStream(file.originalname, {
      metadata: { mimetype: file.mimetype }
    });

    // Utilisez directement le buffer en m√©moire pour envoyer le fichier √† GridFS
    uploadStream.write(file.buffer);
    uploadStream.end();

    uploadStream.on('error', (err) => {
      reject(new Error('Erreur lors du t√©l√©chargement du fichier : ' + err.message));
    });

    uploadStream.on('finish', () => {
      resolve(uploadStream.id);  // Renvoie l'ID de GridFS apr√®s l'upload
    });
  });
};

app.get('/api/video/:id', (req, res) => {
  const videoId = new mongoose.Types.ObjectId(req.params.id);
  
  const downloadStream = gridFSBucketVideo.openDownloadStream(videoId);
  
  downloadStream.on('error', () => {
    res.status(404).json({ message: 'Vid√©o introuvable' });
  });

  downloadStream.pipe(res);
});
app.get('/api/image/:id', (req, res) => {
  const imageId = new mongoose.Types.ObjectId(req.params.id);
  
  const downloadStream = gridFSBucketImage.openDownloadStream(imageId);
  
  downloadStream.on('error', () => {
    res.status(404).json({ message: 'Image introuvable' });
  });

  downloadStream.pipe(res);
});
app.get('/api/videos', async (req, res) => {
  try {
    // R√©cup√©rer toutes les vid√©os
    const videos = await Video.find();

    // Organiser les vid√©os par cat√©gorie
    const categories = [];

    const categoriesMap = {};

    for (let video of videos) {
      // V√©rification de la cat√©gorie de la vid√©o
      const categoryId = video.categoryId;

      if (!categoriesMap[categoryId]) {
        categoriesMap[categoryId] = {
          id: categoryId,
          name: categoryId,
          videos: []
        };
      }

      // G√©n√©rer l'URL de l'image et de la vid√©o depuis GridFS
      const imageUrl = `/api/image/${video.imageFileId}`;
      const videoUrl = `/api/video/${video.videoFileId}`;

      categoriesMap[categoryId].videos.push({
        id: video._id.toString(),
        title: video.title,
        isPaid: video.isPaid,
        categoryId: categoryId,
        image: imageUrl, // Utiliser l'URL g√©n√©r√©e pour l'image
        details: {
          title: video.details?.title || 'Pas de titre',
          video: videoUrl, // Utiliser l'URL g√©n√©r√©e pour la vid√©o
          description: video.details?.description || 'Pas de description'
        }
      });
    }

    // Convertir l'objet en tableau de cat√©gories
    for (const categoryId in categoriesMap) {
      categories.push(categoriesMap[categoryId]);
    }

    res.status(200).json(categories);
  } catch (error) {
    console.error('Erreur lors de la r√©cup√©ration des vid√©os :', error);
    res.status(500).json({ message: 'Erreur interne du serveur' });
  }
});

// Lancement du serveur
server.listen(PORT, () => {
  console.log(`üöÄ Serveur lanc√© sur le port ${PORT}`);
});
